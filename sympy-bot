#! /usr/bin/env python

import sys
import os
import ConfigParser

from argparse import ArgumentParser, ArgumentDefaultsHelpFormatter
from tempfile import mkdtemp

from utils import (cmd, github_get_pull_request,
        github_authenticate, pastehtml_upload, reviews_sympy_org_upload,
        github_add_comment_to_pull_request, list_pull_requests,
        get_interpreter_version_info, get_interpreter_exe, github_get_user_info)
from testrunner import run_tests
from url_templates import URLs

default_testcommand = "setup.py test"
default_interpreter = ["python"]
default_interpreter3 = ["python3"]
default_protocol = "https"

def main():
    global default_interpreter
    global default_interpreter3

    # Subclass argparser so help message is displayed when no args passed
    class BotArgumentParser(ArgumentParser):
        def error(self, message):
            if message == "too few arguments":
                self.print_help(sys.stderr)
            else:
                self.print_usage(sys.stderr)
            self.exit(2, '%s: error: %s\n' % (self.prog, message))

    parser = BotArgumentParser(
            epilog="For the full help on the  review and list commands, run "
            "'sympy-bot command -h'.",
            formatter_class=ArgumentDefaultsHelpFormatter)
    subparsers = parser.add_subparsers(title="command", dest="command")

    parser_review = subparsers.add_parser("review",
        description="Reviews specified pull requests.",
        help="Reviews pull requests",
        formatter_class=ArgumentDefaultsHelpFormatter)
    parser_review.add_argument("n", nargs="+",
        help="Numbers of pull requests to review. You can also specify 'all' "
        "or 'mergable' pull requests.")
    parser_review.add_argument("--profile", type=str, default="default",
        help="Configuration file profile to use, see README for information "
        "about setting up profiles")
    parser_review.add_argument("-n", "--no-upload", action="store_true",
        help="Do not upload the review to the server")
    parser_review.add_argument("-3", "--python3", action="store_true",
        help="Force use of Python 3.x, changes default interpreter to "
        "python3")
    parser_review.add_argument("-D", "--build-docs", action="store_true",
        help="Test the building of the Sphinx HTML documentation")
    parser_review.add_argument("--no-comment", dest="comment",
        action="store_false", help="Upload review but do not submit summary "
        "comment to pull request on GitHub")
    parser_review.add_argument("-i", "--interpreter", action="append",
        nargs="?", type=str, default=default_interpreter, help="Python "
        "interpreter used run tests")
    parser_review.add_argument("-t", "--testcommand", type=str,
        default=default_testcommand, metavar="COMMAND", help="Command, run as "
        "an argument of `python`, used to execute tests, allowing the use of "
        "sympy-bot on a subset of the tests, to run a command that is not an "
        "argument of `python`, add '-V;' to the beginning of the option, for "
        "example '-V; mycommand'")
    parser_review.add_argument("--build-docs-command", type=str,
        default="make html-errors", metavar="COMMAND", help="Command run to "
        "build the Sphinx docs")
    parser_review.add_argument("--build-docs-dir", type=str, default="doc",
        metavar="DIR", help="Directory in which to build the Sphinx docs")
    parser_review.add_argument("-r", "--reference", type=str, help="Path to "
        "sympy repository, passed to 'git clone <sympy repo>', setting this "
        "speeds up sympy-bot and decreases network traffic")
    parser_review.add_argument("--profile", type=str, default="default",
        help="Configuration file profile to use, see README for information "
        "about setting up profiles")
    parser_review.add_argument("-m", "--master-commit", type=str,
        default="origin/master", metavar="COMMIT", help="Commit to use as "
        "master for merging, use 'HEAD' to not merge")
    parser_review.add_argument("-p", "--protocol", type=str,
        default=default_protocol, choices=["https", "git"], help="Protocol "
        "for communicating with GitHub")
    parser_review.add_argument("-s", "--server", type=str,
        default="http://reviews.sympy.org", help="Server to upload results")
    parser_review.add_argument("-R", "--repository", type=str, default="sympy/sympy",
        help="GitHub repository used, allowing sympy-bot to be used with "
        "other projects")

    parser_list = subparsers.add_parser("list",
        description="Lists available pull requests",
        help="Lists available pull requests",
        formatter_class=ArgumentDefaultsHelpFormatter)
    parser_list.add_argument("-n", "--numbers", action="store_true",
        help="List only the numbers of open pull requests, suitable for "
        "piping into 'xargs -L 1 sympy-bot review'")
    parser_list.add_argument("--profile", type=str, default="default",
        help="Configuration file profile to use, see README for information "
        "about setting up profiles")
    parser_list.add_argument("-R", "--repository", type=str, default="sympy/sympy",
        help="GitHub repository used, allowing sympy-bot to be used with "
        "other projects")

    # Initial parse to print help
    options = parser.parse_args()
    # Load configuration and set defaults from it
    config = load_config_file(options.profile)
    # Parse args that should be booleans, but come as strings from ConfigParser
    for i in ("build_docs", "no_comment", "no_upload", "python3"):
        if i in config:
            if isinstance(config[i], str):
                if config[i].strip().lower() in ("true", "y", "yes"):
                    config[i] = True
                elif config[i].strip().lower() in ("false", "n", "no"):
                    config[i] = False
                else:
                    raise ConfigParser.Error("Unable to parse boolean configuration value for %s" % i)
    # If interpreter is set in config file, force tests to run
    parser.set_defaults(interpreter=None)
    if "interpreter" in config:
        default_interpreter = [i.strip() for i in config.pop("interpreter").split(",")]
        parser.set_defaults(interpreter=[None])
    if "interpreter3" in config:
        default_interpreter3 = [i.strip() for i in config.pop("interpreter3").split(",")]
    parser.set_defaults(**config)
    # Parse args
    options = parser.parse_args()

    gh_user, gh_repo = options.repository.split("/")
    urls = URLs(user=gh_user, repo=gh_repo)

    if options.command == "list":
        list_pull_requests(urls, numbers_only=options.numbers)
    elif options.command == "review":
        # Passed a bare `-i` command
        if options.interpreter == [None]:
            if options.python3:
                options.interpreter = default_interpreter3
            else:
                options.interpreter = default_interpreter
        # No command line interpreter
        elif options.interpreter is None:
            # -D with no -i and no -3 runs with no interpreters
            if options.build_docs and not options.python3:
                options.interpreter = []
            elif options.python3:
                options.interpreter = default_interpreter3
            else:
                options.interpreter = default_interpreter

        if options.n == "mergable":
            print "> Reviewing all *mergeable* pull requests"
            print
            nonmergeable, mergeable = list_pull_requests(urls, numbers_only=True)
            options.n = mergeable
        elif options.n == "all":
            print "> Reviewing *all* pull requests"
            print
            nonmergeable, mergeable = list_pull_requests(urls, numbers_only=True)
            options.n = nonmergeable + mergeable
        else:
            # list of pull request numbers, convert it:
            options.n = map(int, options.n)

        if not options.no_upload:
            username, password = github_authenticate(urls.api_url, config.get("user"), config.get("password"))
        else:
            username = password = None

        try:
            dispatch_reviews(options, urls, username=username, password=password)
        except KeyboardInterrupt:
            print "\n> Quitting on signal SIGINT."
            sys.exit(1)

def load_config_file(profile):
    conf_file = os.path.normpath('~/.sympy/sympy-bot.conf')
    conf_file = os.path.expanduser(conf_file)

    parser = ConfigParser.SafeConfigParser()

    if os.path.exists(conf_file):
        print "> Using config file %s" % conf_file
        with open(conf_file) as f:
            try:
                parser.readfp(f)
            except IOError:
                print "> WARNING: Unable to open config file"
            except ConfigParser.Error:
                print "> WARNING: Unable to parse config file"
            finally:
                print "> Loaded configuration file"

                if parser.has_section(profile):
                    items = dict(parser.items(profile))
                else:
                    print "> WARNING: Configuration file does not contain profile %s" % profile
                    items = {}

                if profile != "default" and parser.has_section("default"):
                    items = dict(parser.items("default", vars=items))

                return items
    return {}

def dispatch_reviews(config, urls, **kwargs):
    username = kwargs.get("username", None)
    password = kwargs.get("password", None)
    nums = config.n
    interpreters = config.interpreter

    # Check interpreters
    python3 = dict( [(i, get_interpreter_version_info(i)[0] == '3') for i in interpreters] )
    if config.python3 and not all(python3.itervalues()):
        raise ValueError("Python 2 interpreter passed with -3 option")

    tmpdir = mkdtemp(prefix="sympy-bot-tmp")
    print "> Working directory: %s" % tmpdir

    print "> Cloning %s master" % config.repository
    if config.reference:
        reference = os.path.abspath(os.path.expanduser(os.path.expandvars(config.reference)))
        cmd("cd %s && git clone --reference %s git://github.com/%s.git" % (tmpdir, reference, config.repository))
    else:
        cmd("cd %s && git clone git://github.com/%s.git" % (tmpdir, config.repository))

    # Open log file
    log_file = os.path.join("%s" % tmpdir, "out", "log")
    logdir = os.path.join(tmpdir, "out")
    os.mkdir(logdir)
    with open(log_file, "w") as log:
        # Generate all reviews
        reviews = {}
        for n in nums:
            # Write pull request info
            pull = github_get_pull_request(urls.single_pull_template, n)
            assert pull["number"] == n
            print "> Reviewing pull request #%d" % n
            repo_url = pull["head"]["repo"]["html_url"]
            repo_url = repo_url.replace(default_protocol, config.protocol)
            branch = pull["head"]["ref"]
            user = pull["head"]["user"]
            user_info = github_get_user_info(urls.user_info_template, username)
            # TODO: Author broken
            author = "\"%s\" <%s>" % (user_info.get("name", "unknown"),
                                      user_info.get("email", ""))
            print "> Pull request info:"
            print unicode(">     Author: %s" % author).encode('utf8')
            print ">     Repository: %s" % repo_url
            print ">     Branch: %s" % branch

            pull_review = {}
            # Iterate over interpreters
            for i in interpreters:
                # Run tests
                print "> Testing interpreter %s" % i
                command = "%s %s" % (i, config.testcommand)
                repo_path = os.path.join(tmpdir, "sympy")
                result = run_tests(repo_url, branch, repo_path, command,
                        python3[i], config.master_commit)
                if result["result"] == "error":
                    print "There was an error. Report not uploaded."
                    sys.exit(1)
                print "> Done."
                print

                pull_review[i] = result
                log.write(result["log"])
            if config.build_docs:
                print "> Building Sphinx docs"
                repo_path = os.path.join(tmpdir, "sympy", config.build_docs_dir)
                result = run_tests(repo_url, branch, repo_path,
                        config.build_docs_command, False, config.master_commit)
                if result["result"] == "error":
                    print "There was an error. Report not uploaded."
                    sys.exit(1)
                print "> Done."
                print

                pull_review["build docs"] = result
                log.write(result["log"])
        pull_review["master_hash"] = result["master_hash"]
        pull_review["branch_hash"] = result["branch_hash"]
        reviews[n] = pull_review
        print "> View log at: %s" % log_file

    # Summarize and upload results
    for n, pull_review in reviews.iteritems():
        master_hash = pull_review.pop("master_hash")
        branch_hash = pull_review.pop("branch_hash")
        report_status = dict([(i, result["result"]) for i, result in pull_review.iteritems()])
        xpassed = dict([(i, result["xpassed"]) for i, result in pull_review.iteritems()])

        if not config.no_upload:
            print "> Uploading test results for pull number %d" % n
            url_base = config.server
            data = dict([(i, {
                "num" : n,
                "result" : report_status[i],
                "interpreter": i,
                "log": pull_review[i]["log"],
                "testcommand": config.testcommand,
                "master_hash": master_hash,
                "branch_hash": branch_hash,
            }) for i in pull_review.iterkeys()])
            report_url = dict([(i, reviews_sympy_org_upload(data[i], url_base)) for i in pull_review.iterkeys()])
            for i, url in report_url.iteritems():
                print "> Uploaded report for '%s' at: %s" % (i, url)
        else:
            report_url = dict([(i, "(report was not uploaded)") for i in pull_review.iterkeys()])
        review = formulate_review(report_url, report_status, xpassed,
                master_hash, branch_hash, user, config)
        print "> Review:"
        print review
        if not config.no_upload and config.comment:
            print "> Uploading the review to the GitHub pull request ..."
            github_add_comment_to_pull_request(urls.issue_comment_template, \
                                               username, password, n, review
                                              )
            print ">     Done."
            print "> Check the results: https://github.com/%s/pull/%d" % (config.repository, n)

def formulate_review(report_url, report_status, xpassed, master_hash, branch_hash, user, config):
    user = user.get("login", None)

    if user:
        atuser = "@"+user+": "
    else:
        atuser = ""
    if any([status == "conflicts" for status in report_status.itervalues()]):
        summary = """:exclamation: There were merge conflicts; could not test the branch.

%sPlease rebase or merge your branch with master.  \
See the report for a list of the merge conflicts.""" % atuser
    elif any([status == "fetch" for status in report_status.itervalues()]):
        summary = """:x: Could not fetch the branch.

%sPlease run the sympy-bot tests again.""" % atuser
    elif any([status == "Failed" for status in report_status.itervalues()]):
        summary = """:red_circle: There were test failures.

%sPlease fix the test failures.""" % atuser
    elif all([status == "Passed" for status in report_status.itervalues()]):
        summary = """:eight_spoked_asterisk: All tests have passed."""
    else:
        raise ValueError("Unknown report_status")

    if config.testcommand != default_testcommand:
        bold = "**"
    else:
        bold = ""
    details = """*Test command:* %s%s%s\n""" % (bold, config.testcommand, bold)
    details += """*master hash*: %s\n""" % master_hash
    details += """*branch hash*: %s\n""" % branch_hash

    if len(config.interpreter) == 0:
        report = """\
**SymPy Bot Summary:** %s\n""" % summary
    else:
        report = """\
**SymPy Bot Summary:** %s

%s""" %  (summary, details)

    for n, i in enumerate(config.interpreter, start=1):
        details = get_platform_version(i)
        status = report_status[i]
        if status == "conflicts":
            summary = """:exclamation: There were merge conflicts; could not test the branch."""
        elif status == "fetch":
            summary = """:x: Could not fetch the branch."""
        elif status == "Failed":
            summary = """:red_circle: There were test failures."""
        elif status == "Passed":
            summary = """:eight_spoked_asterisk: All tests have passed."""
        else:
            raise ValueError("Unknown report_status")

        if len(config.interpreter) > 1:
            report += """\n**Interpreter %d:** %s\n\n""" % (n, summary)
        report += """%s
Test results html report: %s\n""" % (details, report_url[i])


    if config.build_docs:
        details = get_sphinx_version()
        status = report_status["build docs"]
        if status == "conflicts":
            summary = """:exclamation: There were merge conflicts; could not test the branch."""
        elif status == "fetch":
            summary = """:x: Could not fetch the branch."""
        elif status == "Failed":
            summary = """:red_circle: There were test failures."""
        elif status == "Passed":
            summary = """:eight_spoked_asterisk: All tests have passed."""
        else:
            raise ValueError("Unknown report_status")

        report += """\n**Build HTML Docs:** %s

*Docs build command:* %s
%s

Test results html report: %s\n""" % (summary, config.build_docs_command, details, report_url["build docs"], )

    report += """\nAutomatic review by [SymPy Bot](https://github.com/sympy/sympy-bot)."""
    return report

def get_executable(interpreter):
    path = os.environ['PATH']
    paths = path.split(os.pathsep)
    interpreter_exe = None
    if os.name=="nt":
        return get_interpreter_exe(interpreter)
    if os.path.isfile(interpreter):
        return interpreter
    else:
        for p in paths:
            f = os.path.join(p, interpreter)
            if os.path.isfile(f):
                return f

def get_platform_version(interpreter):
    from os import getenv
    import platform
    # Python 2.5 doesn't have sys.maxsize
    code = 'import sys; print(getattr(sys, "maxint", None))'
    call = "%s -c '%s'" % (interpreter, code)
    size = cmd(call, capture=True)
    if size == 'None\n': #Python 3 doesn't have maxint
        code = 'import sys; print(sys.maxsize)'
        call = "%s -c '%s'" % (interpreter, code)
        size = cmd(call, capture=True)
    size = int(size)
    if size > 2**32:
        architecture = "64-bit"
    else:
        architecture = "32-bit"
    platfotm_system = platform.system()
    use_cache = getenv('SYMPY_USE_CACHE', 'yes').lower()
    executable = get_executable(interpreter)
    python_version = get_interpreter_version_info(interpreter)
    r  = "*Interpreter:*  %s (%s)\n" % (executable, python_version)
    r += "*Architecture:* %s (%s)\n" % (platfotm_system, architecture)
    r += "*Cache:*        %s\n" % use_cache
    return r

def get_sphinx_version():
    import sphinx
    version = sphinx.__version__
    r = "*Sphinx version:* %s" % version
    return r

if __name__ == "__main__":
    main()
    sys.exit(0)
